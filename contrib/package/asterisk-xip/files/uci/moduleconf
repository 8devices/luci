#!/bin/sh

# Module.conf

init_moduleconf() {
	ast_add_reload module
	ast_enable_type module

	for i in ${module_list} ; do
		eval module_${i}=no
	done

	enable_module app_dial
	enable_module app_read

	enable_module app_verbose
	enable_module pbx_config
	enable_module pbx_functions

	enable_module app_transfer
	module_chan_local=auto
	# Sound files are all gsm
	enable_format gsm

	enable_module app_func_strings
}

# List of modules in sensible load order.
module_list="res_agi res_adsi res_config_mysql res_crypto res_smdi res_features \
 res_indications res_convert res_jabber res_monitor res_musiconhold res_speech \
 res_clioriginate pbx_ael pbx_config pbx_functions pbx_loopback pbx_realtime \
 pbx_spool pbx_wilcalu func_base64 func_callerid func_cdr func_channel func_cut \
 func_db func_enum func_env func_global func_groupcount func_language func_logic \
 func_moh func_rand func_realtime func_sha1 func_strings func_timeout func_uri \
 cdr_csv cdr_custom cdr_manager cdr_mysql cdr_pgsql cdr_sqlite chan_agent \
 chan_alsa chan_gtalk chan_h323 chan_iax2 chan_local chan_sip format_au \
 format_g723 format_g726 format_g729 format_gsm format_h263 format_h264 \
 format_ilbc format_jpeg format_mp3 format_pcm format_pcm_alaw format_sln \
 format_vox format_wav format_wav_gsm app_alarmreceiver app_amd app_authenticate \
 app_cdr app_chanisavail app_channelredirect app_chanspy app_controlplayback \
 app_cut app_db app_dial app_dictate app_directed_pickup app_directory app_disa \
 app_dumpchan app_echo app_enumlookup app_eval app_exec app_externalivr \
 app_followme app_forkcdr app_getcpeid app_groupcount app_hasnewvoicemail \
 app_ices app_image app_lookupblacklist app_lookupcidname app_macro app_math \
 app_md5 app_meetme app_milliwatt app_mixmonitor app_morsecode \
 app_parkandannounce app_playback app_privacy app_queue app_random app_read \
 app_readfile app_realtime app_record app_sayunixtime app_senddtmf app_sendtext \
 app_setcallerid app_setcdruserfield app_setcidname app_setcidnum app_setrdnis \
 app_settransfercapability app_sms app_softhangup app_speech_utils app_stack \
 app_system app_talkdetect app_test app_transfer app_txtcidname app_url \
 app_userevent app_verbose app_voicemail app_waitforring app_waitforsilence \
 app_while codec_a_mu codec_adpcm codec_alaw codec_g726 codec_gsm codec_ilbc \
 codec_lpc10 codec_speex codec_ulaw"

# Enable a module - for use by other scripts
enable_module() {
	logdebug 3 "Enable ${1}"
	eval module_${1}=yes
}

module_enabled() {
	eval local is_enabled="\${module_${1}}"
	if [ ${is_enabled} == "no" ] ; then
		return 1
	else
		return 0
	fi
}

# Enable a sound format - for use by other scripts
enable_format() {
	while [ ! -z $1 ] ; do
		case $1 in
			gsm)
				enable_module format_gsm
				enable_module codec_gsm
				[ "${module_format_wav}" = "yes" ] && enable_module format_wav_gsm ;;
			wav)
				enable_module format_wav
				[ "${module_format_gsm}" = "yes" ] && enable_module format_wav_gsm ;;
			alaw)
				enable_module codec_adpcm
				enable_module codec_alaw
				[ "${module_format_pcm}" = "yes" ] && enable_module format_pcm_alaw ;;
			pcm)
				enable_module format_pcm_alaw
				[ "${module_format_alaw}" = "yes" ] && enable_module format_pcm_alaw ;;
			ulaw)
				enable_module codec_ulaw ;;
			g729|g726|g723)
				enable_module format_g726
				enable_module codec_g726 ;;
			ilbc)
				enable_module format_ilbc
				enable_module codec_ilbc ;;
			sln)   enable_module format_sln ;;
			mp3)   enable_module format_mp3 ;;
			vox)   enable_module format_vox ;;
			speex) enable_module codec_speex ;;
		esac
		shift
	done
}

create_moduleconf() {
	local file=${DEST_DIR}/modules.conf

	get_checksum module_conf $file

	rm -f ${file}.orig
	[ -f "${file}" ] && mv ${file} ${file}.orig

	echo "${asteriskuci_gen}[modules]${N}autoload=yes" > $file
	for i in ${module_list} ; do
		eval res=\${module_${i}}
		case $res in
			yes) echo "load   => $i.so" >> $file ;;
			no)  echo "noload => $i.so" >> $file ;;
		esac
	done
	echo "${N}[global]${N}chan_modem.so=no"  >> $file

	check_checksum "$module_conf" "$file"  || ast_module_restart=1
}

reload_module() {
	local file=${DEST_DIR}/modules.conf
	local cmd=`diff ${file}.orig ${file} -u -U0 | grep '^+\(no\)\?load' | sed 's/+load[[:space:]]*=>[[:space:]]*\(.*\)$/\"module load \1\"/' | sed 's/+noload[[:space:]]*=>[[:space:]]*\(.*\)$/\"module unload \1\"/'| tr '\n' ' '`
	[ "${testing_mode}" != "1" ] && rm -f ${file}.orig
	logdebug 3 "Module reload: ${N}$cmd"
	eval "astcmds $cmd"
}


valid_module() {
	is_in_list $1 ${module_list}
	return $?
}

handle_module() {
	option_cb() {
		if valid_module $1 ; then
			eval module_$1="$2"
		else
			logerror "Invalid module: $1"
		fi
	}
}


# vim: ts=2 sw=2 noet foldmethod=indent
